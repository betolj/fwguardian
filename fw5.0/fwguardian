#!/bin/bash
#
# FWGUARDIAN Project (v5.0)
#
# (C) 2014 by Humberto L Juc√° <betolj@gmail.com>
#
# This software may be used and distributed according to the terms
# of the GNU General Public License, incorporated herein by reference.
#
# http://sourceforge.net/projects/humbertolj/
#

ip=$(which ip 2>/dev/null)
sh=$(which bash 2>/dev/null)
ipset=$(which ipset)
setkey=$(which setkey 2>/dev/null)
iptables=$(which iptables 2>/dev/null)
FW_DIR=$(readlink -f "$(dirname $0)"/)
sedipt=$(echo $iptables | sed "s/\//\\\\\//g")
igawk=$(which igawk 2>/dev/null)

fwver=5.0.stable

### Make control dir 
[ ! -d /usr/share/fwguardian/include ] || \
[ ! -d /usr/share/fwguardian/modules ] && \
  mkdir -p /usr/share/fwguardian/{include,modules}

### Error logs and iptables commands
[ ! -d $FW_DIR/logs ] || \
[ ! -d $FW_DIR/build ] && \
  mkdir -p $FW_DIR/{logs,build}

### Finding the main dependences
test -f "$igawk" || {
  clear
  echo -e '\n\E[48;31m'"\033[1m ERROR: INITIALIZE FIREWALL SCRIPT!!!\033[0m"
  echo -e "\tI cant find igawk binary"
  echo -en "\t*** igawk binary is required ***\n\n"
  echo -e "\tInstall examples: urpmi gawk or yum install gawk"
  echo -e "\t                  or apt-get install gawk"
  exit
}

test -f "$iptables" || {
  clear
  echo -e '\n\E[48;31m'"\033[1m ERROR: INITIALIZE FIREWALL SCRIPT!!!\033[0m"
  echo -e "\n\tI can't find the iptables binary!"
  echo -e "\t***iptables binary is required***\n\n"
  exit
}

killweb() { 
  ### Kill current webauth and chkweb pid
  kill -9 $(cat /usr/share/fwguardian/webauth/control/chkweb.pid 2>/dev/null) 2>/dev/null >/dev/null
  kill $(cat /usr/share/fwguardian/webauth/control/webauth.pid 2>/dev/null) 2>/dev/null
  rm -f /usr/share/fwguardian/webauth/control/chkweb.pid 2>/dev/null
  rm -f /usr/share/fwguardian/webauth/control/webauth.pid 2>/dev/null
}

killclctl() {
  ### Kill current clusterctl pid
  if [ -f /var/tmp/cluster.pid ]; then 
     kill $(cat /var/tmp/cluster.pid 2>/dev/null) 2>/dev/null
     rm -f /var/tmp/cluster.pid 2>/dev/null
  else
     ps -ef | grep clusterctl.pl | awk '/cluster\/clusterctl.pl/ {print "kill -9 "$2;}' | $sh - 2>/dev/null
  fi
}

flush_rttables() {
  ### Flush lb routing tables
  if [ -f $FW_DIR/build/.table.undo ]; then
     $sh $FW_DIR/build/.table.undo 2>/dev/null
     for i in $(ls /usr/share/fwguardian/*.lbtable 2>/dev/null); do
        lbtable=$(basename $i | sed 's/\..*//')
        $ip route flush table $lbtable 2>/dev/null
     done
     rm -f /usr/share/fwguardian/*.lbtable 2>/dev/null
     rm -f $FW_DIR/build/.table.undo
  fi
}

help() {
  echo -e "\nFwGuardian 'options'\n"
  echo "--help                             this help"
  echo "--reload-profile <profile>         reload a especify profile"
  echo "--reload-trust                     reload the TRUST admin address (console)"
  echo "--reload-fwhosts                   reload the hosts profile (fwhosts)"
  echo "--reload-rules                     reload routing and input rules (fwroute.rules)"
  echo "--reload-nat                       reload nat config (fwroute.nat)"
  echo "--reload-qos                       reload QoS config (tfshape/shape.conf)"
  echo "--reload-vpn                       reload VPN config (vpn/vpn.conf)"
  echo "--reload-msn                       reload MSN config (fwmsn)"
  echo "--reload-banned routes             reload bannedroutes rules"
  echo "--reload-banned access             reload bannedaccess rules (for rtif interface)"
  echo "--reload-advrouting                reload alternative routing tables definitions (iproute)"
  echo "--make-https-cert                  create a new cert and key for https webauth"
  echo "--web-start                        start the webauth server (perl HTTP server)"
  echo "--web-stop                         stop the webauth server (perl HTTP server)"
  echo "--allow-reset-auths                allow reset all user sessions when restart server (perl HTTP server)"
  echo "--vpn-stop                         stop vpn servers"
  echo "--configure-vpnserver              allow PPTP/IPSEC VPN servers configure on module (re)start (vpn/vpn.conf)"
  echo "--configure-cluster                configure the cluster mode and VIP rules (cluster/cluster.conf)"
  echo "--reconfigure-gluster              (re)configure gluster mapping (cluster/gluster.mapps)"
  echo "--reconfigure-interfaces           allow a full interface setup (interfaces) !!!"
  echo "--show-modules                     show supported firewall modules"
  echo "--enable                           enable a firewall module"
  echo "--disable                          disable a firewall module"
  echo "--list-nat-conntrack               list ip_nat supported modules"
  exit 0
}

### Trust hosts functions
lstTrust() {
   local icont=0
   for i in $(grep -v "^\s*\(#\|;\)" $FW_DIR/accesslist/trust);
   do
      TRUST[$icont]=$i
      ((icont++))
   done
   unset icont
}

updTrust() {
  $iptables -A AllowAdmin -p tcp --syn -m hashlimit --hashlimit-mode srcip,dstip,dstport --hashlimit-htable-max 500 --hashlimit 3/min --hashlimit-burst 3 --hashlimit-name fwadmin -j LOG --log-level info --log-prefix "fwguardian(admin):" 2>/dev/null
  $iptables -A AllowAdmin -j ACCEPT
  for i in $(echo ${TRUST[*]});
  do
     ifdev=$(ip route get $i 2>/dev/null | grep -v local | head -1 | sed 's/.* dev //' | cut -d" " -f1)
     [ "$ifdev" ] && $iptables -A FwAdmin -i $ifdev -s $i -j AllowAdmin 2>/dev/null || \
        $iptables -A FwAdmin -s $i -j AllowAdmin 2>/dev/null
  done
  unset ifdev
}

updFwHosts() {
  [ -f $FW_DIR/build/.fwhosts.undo ] && $sh $FW_DIR/build/.fwhosts.undo 2>/dev/null
  $FW_DIR/modules/fwhosts.mod $FW_DIR >/dev/null 2>/dev/null
}

### Options
lnoption=$1
[ -x $FW_DIR/preload ] && $FW_DIR/preload $1 2>&1 >>$FW_DIR/logs/preload.err
case "$lnoption" in 
    --help) help  ;;
    --reload-rules)
      echo "Reloading... routing and input rules definitions !!!"
      $FW_DIR/modules/rtfilters.mod $FW_DIR/routing >/dev/null 2>/dev/null
      $iptables -F FwIn 2>/dev/null
      $FW_DIR/modules/infilters.mod $FW_DIR >/dev/null 2>/dev/null ;;
    --reload-trust)
      echo "Reloading... Trust hosts definition !!!"
      lstTrust
      $iptables -F FwAdmin 2>/dev/null
      $iptables -F AllowAdmin 2>/dev/null
      updTrust ;;
    --reload-profile)
      rsquid=0
      rvpop3=0
      echo "Reloading... $2 profile !!!"
      $FW_DIR/modules/profile.mod $FW_DIR/profile $2 >/dev/null 2>/dev/null
      [ "$2" == "vpop3" ] || [ "$2" == "profile" ] && rvpop3=1
      [ "$2" == "rsquid" ] || [ "$2" == "profile" ] && rsquid=1
      [ $rvpop3 -eq 1 ] && [ -f /usr/share/fwguardian/vpop3.natrules ] && $sh /usr/share/fwguardian/vpop3.natrules 2>$FW_DIR/logs/profile.err
      [ $rsquid -eq 1 ] && [ -f /usr/share/fwguardian/rsquid.natrules ] && $sh /usr/share/fwguardian/rsquid.natrules 2>$FW_DIR/logs/profile.err ;;
    --reload-fwhosts)
      echo "Reloading... hosts profile !!!"
      updFwHosts ;;
    --reload-banned)
      echo "Reloading... banned $2 list !!!"
      $FW_DIR/modules/bannedfw.mod $FW_DIR $2 >/dev/null 2>/dev/null
      if [ "$2" == "access" ] && [ -f /usr/share/fwguardian/modules/fwhosts.ctl ]; then
         updFwHosts
      fi ;;
    --reload-dnat|--reload-nat)
      echo "Reloading... NAT config !!!"
      $FW_DIR/modules/rtnat.mod $FW_DIR/routing >/dev/null 2>/dev/null ;;
    --reload-qos)
      echo "Reloading... QoS config !!!"
      $FW_DIR/modules/tfstart.mod $FW_DIR/tfshape >/dev/null 2>/dev/null ;;
    --reload-vpn)
      echo "Reloading... VPN config !!!"
      if [ -f $FW_DIR/build/.vpn.undo ]; then
         $sh $FW_DIR/build/.vpn.undo 2>/dev/null
         rm -f $FW_DIR/build/.vpn.undo 2>/dev/null
      fi
      $FW_DIR/modules/vpnfw.mod $FW_DIR/vpn init all >/dev/null 2>/dev/null
      [ -f /usr/share/fwguardian/modules/msnctl.ctl ] && $FW_DIR/modules/msnctl.mod $FW_DIR/ >/dev/null 2>/dev/null ;;
    --configure-vpnserver)
      echo "Configuring... Allow VPN server configure on module (re)start !!!"
      [ -f /usr/share/fwguardian/modules/vpnfw.ctl ] && touch /var/tmp/vpn.configureserver ;;
    --reload-msn)
      echo "Reloading... MSN config !!!"
      $FW_DIR/modules/msnctl.mod $FW_DIR/ >/dev/null 2>/dev/null ;;
    --reload-advrouting|--reload-rttables)
      flush_rttables
      echo "Reloading... alternative routing tables definitions !!!"
      $FW_DIR/modules/rttables.mod $FW_DIR/routing >/dev/null 2>/dev/null ;;
    --configure-cluster)
      echo "Configuring... Cluster mode and VIP rules !!!"
      $FW_DIR/modules/clusterbase.mod $FW_DIR/cluster >/dev/null ;;
    --reconfigure-gluster)
      echo "(re)Configuring... Gluster mapping !!!"
      touch /var/tmp/glusterfs.reconfigure ;;
    --reconfigure-interfaces)
      echo "(re)Configuring... Allow a full interface setup (you should restart the firewall script) !!!"
      touch /tmp/interfaces.update ;;
    --make-https-cert)
      $FW_DIR/modules/tools/ssl/mkssl.sh $FW_DIR/modules/tools/ssl ;;
    --ignore-webserver)
      touch /usr/share/fwguardian/webauth/control/ignore ;;
    --ignore-cluster)
      touch /usr/share/fwguardian/webauth/control/ignore.cluster ;;
    --web-start)
      echo "Starting... webauth server !!!"
      killweb
      $FW_DIR/webauth/webstart $FW_DIR/webauth >/dev/null ;;
    --web-stop)
      echo "Stoping... webauth server !!!"
      killweb ;;
    --allow-reset-auths)
      echo "Allow reset user sessions in next webserver restart !!!"
      touch /usr/share/fwguardian/webauth/control/reset ;;
    --vpn-stop)
      echo "Stoping... vpn servers !!!"
      $FW_DIR/modules/vpnfw.mod $FW_DIR/vpn stop all ;;
    --enable-daemon)
      cp -f $FW_DIR/modules/tools/fwguardian /etc/init.d/
      chmod +x /etc/init.d/fwguardian
      if [ -d "/etc/default" ]; then
         echo "FW_DIR=$FW_DIR" > /etc/default/fwguardian
         update-rc.d fwguardian defaults 50 90
      else
         echo "FW_DIR=$FW_DIR" > /etc/sysconfig/fwguardian
         chkconfig fwguardian on
      fi
      exit ;;
    --force-hardware-reboot)
      echo "Force hardware reboot!!!"
      echo "- press ctrl+c to abort"
      echo "- press any key to reboot"
      read
      echo 1 >/proc/sys/kernel/sysrq
      echo s >/proc/sysrq-trigger
      sleep 1
      echo b >/proc/sysrq-trigger ;;
    --show-modules)
      clear 
      echo "Firewall modules..."
      ls --color=none $FW_DIR/modules/*.mod | grep -v "chk.*\.mod\|flush.*\.mod\|rtsec\|rtdgd\|vpndgd" | \
        awk '{print $1" --help";}' | $sh -
      echo ; echo -n "Actived modules... [--enable|--disable]"
      echo -e '\E[48;34m'"\033[1m"
      ls /usr/share/fwguardian/modules/* 2>/dev/null | sed 's/.*\///;s/\.ctl$/ /' | tr -d '[\n]'
      echo -e '\033[0m' ;;
    --enable)
      if [ "$(ls $FW_DIR/modules/$2.mod 2>/dev/null | wc -l)" -eq 1 ]; then
         touch /usr/share/fwguardian/modules/$2.ctl
	 echo -n "Actived modules... (reload the firewall script)"
	 echo -e '\E[48;34m'"\033[1m"
         ls /usr/share/fwguardian/modules/* 2>/dev/null | sed 's/.*\///;s/\.ctl$/ /' | tr -d '[\n]'; echo -n
	 echo -e '\033[0m'
	 [ "$3" == "now" ] && lnoption=""
      else
	 echo -e '\E[48;31m'"\033[1m - Error: Module not found!!!\033[0m"
      fi ;;
    --disable)
      if [ "$(ls $FW_DIR/modules/$2.mod 2>/dev/null | wc -l)" -eq 1 ]; then
         rm -f /usr/share/fwguardian/modules/$2.ctl
	 touch /usr/share/fwguardian/disareq.ctl
	 echo -n "Actived modules... (reload the firewall script)"
	 echo -e '\E[48;34m'"\033[1m"
         ls /usr/share/fwguardian/modules/* 2>/dev/null | sed 's/.*\///;s/\.ctl$/ /' | tr -d '[\n]'; echo -n
	 echo -e '\033[0m'
	 [ "$3" == "now" ] && lnoption=""
      else
	 echo -e '\E[48;31m'"\033[1m - Error: Module not found!!!\033[0m"
      fi ;;
    --list-nat-conntrack)
      clear; echo -e "=== ip_nat modules found in your system ===\n"
      for i in $(find /lib/modules/$(uname -r) -name ??_nat_* -print | grep -i netfilter | \
            sed 's/.*\///' | sed 's/\..*\.gz$//; s/\.ko$//'); do echo $i ; done
      ;;
    *)
      if [ "$lnoption" != "" ]; then
	echo -e "\n=== Invalid option ==="
        help
        exit 0
      fi  ;;
esac

if [ "$lnoption" != "" ]; then
   $FW_DIR/modules/flushnftables.mod start 2>/dev/null
   [ -x $FW_DIR/postload ] && $FW_DIR/postload $lnoption 2>&1 >>$FW_DIR/logs/postload.err
   exit 0
fi

### Treatment after "disable"
if [ -f /usr/share/fwguardian/disareq.ctl ]; then

  ## Flush QoS defs and rttables
  if [ -f "/var/tmp/tfstart.nfchain" ] && [ ! -f "/usr/share/fwguardian/modules/tfstart.ctl" ]; then
     $FW_DIR/modules/tfflush.mod start
     rm -f /var/tmp/tfstart.nfchain
  fi
  if [ -f "/var/tmp/rttables.nfchain" ] && [ ! -f "/usr/share/fwguardian/modules/rttables.ctl" ]; then
     flush_rttables
     rm -f /var/tmp/rttables.nfchain 2>/dev/null
  fi

  ## Remove Cluster defs
  if [ -f /var/tmp/cluster.pid ] && [ ! /usr/share/fwguardian/modules/clusterfw.ctl ]; then
     echo -e ",g/ #pam_clfgaccess/d\nw\nq" | ed "/etc/security/access.conf" >/dev/null 2>&1
     echo -e ",g/ #pam_clfgaccess/d\nw\nq" | ed "/etc/pam.d/sshd" >/dev/null 2>&1

     [ -f "/etc/keepalived/keepalived.conf" ] && $FW_DIR/modules/tools/cluster/vrrp/keepalived run stop 2>/dev/null >/dev/null
     [ -f "/etc/conntrackd/conntrackd.conf" ] && $FW_DIR/modules/tools/cluster/conntrackd/conntrackd run stop 2>/dev/null >/dev/null
     [ -f "/usr/share/fwguardian/cluster.glusterfs-server" ] && $FW_DIR/modules/tools/cluster/glusterfs/glusterfs-server stop 2>/dev/null >/dev/null
     killclctl
  fi

  ## IPSec SAD and SPD flush
  [ ! -f "/usr/share/fwguardian/modules/vpnfw.ctl" ] && $FW_DIR/modules/vpnfw.mod $FW_DIR/vpn stop all

  rm -f /usr/share/fwguardian/disareq.ctl
fi

### Remove control files
rm -f /var/tmp/*.nfchain 2>/dev/null
rm -f /usr/share/fwguardian/*.ctl 2>/dev/null

### Bridge functions
nfbridge=0
[ -f /proc/sys/net/bridge/bridge-nf-call-iptables ] && nfbridge=$(cat /proc/sys/net/bridge/bridge-nf-call-iptables)

### Alias function for firewall modules
walias=""
[ -f $FW_DIR/alias ] && walias="$FW_DIR/alias"
cp -f $FW_DIR/modules/include/alias.inc /usr/share/fwguardian/include/ 2>/dev/null

iflocrt() {
   local icont=0
   if [ "$itype" == "local" ]; then 
     for i in $(echo $@);
     do
        IFLC[$icont]=$i
        ((icont++))
     done
   else
     for i in $(echo $@);
     do
        IFRT[$icont]=$i
	((icont++))
     done
   fi
   unset icont
}

lstDns() {
   local icont=0
   for i in $(echo $@);
   do
      DNS[$icont]=$i  
      ((icont++))
   done
   unset icont
}

lstCtNat() {
   local icont=0
   for i in $(echo $@);
   do
      CTNAT[$icont]=$i  
      ((icont++))
   done
   unset icont
}


echo "Starting routing and firewall resources..."
cat $walias $FW_DIR/fwguardian.conf | grep -v "^#\|^;" | igawk '\
   @include /usr/share/fwguardian/include/alias.inc \
   { if ($1 == "alias") fwalias("make", "fwconf"); \
     else { \
       if (alcont) fwalias("apply", "fwconf"); \
       print $0; \
     } \
}' > /usr/share/fwguardian/fw.conf

IFS=$'\n'
lstTrust
for line in $(grep "[[:alpha:]]" /usr/share/fwguardian/fw.conf);
do
  flag=$(echo $line | awk '{print $1}')
  auxval=$(echo $line | awk '{print $2}')
  case "$flag" in
    ### Access control
    profile) PROFILE=$auxval ;;
    ### Route rules (chain FORWARD)
    keepalive_sessions) KP_SESS=$auxval ;;
    webserver) WEB_SERVER=$auxval ;;
    webhealth) WEB_HEALTH=$auxval ;; 
    ### Adv Routed
    optimize_TOS) OPTOS=$auxval ;;
    violate_TOS) VITOS=$auxval ;;
    fix_TOS) FIXTOS=$auxval ;;
    ### Permission level    
    # IPv4_Dynamic
    ip_dynamic) IPDYN=$auxval ;;
    # IPv4_Forward
    forwarding) IP_FWD=$auxval ;;
    # Masquerade and proxy rules (port 3128)
    net_sharing) SHARENET=$auxval ;;
    # Default access level
    default_profile) PRIV_DEF=$auxval ;;
    ### Security
    kill_web) KWEB=$auxval ;;
    kill_nbt) KNBT=$auxval ;;
    kill_largeping) KLICMP=$auxval ;;
    syn_cookie) SYN_C_FW=$auxval ;;
    rp_filter) RP_F_FW=$auxval ;;
    icmp_bogus_error) I_BE_FW=$auxval ;;
    ignore_brd_icmp) BRD_I_FW=$auxval ;;
    log_martians) LOG_M_FW=$auxval ;;
    send_redirects) SED_REDIR=$auxval ;;
    secure_redirects) SEC_REDIR=$auxval ;;
    deny_src_rt) ACC_SR_FW=$auxval ;;
    deny_icmp_redir) ICMP_A_FW=$auxval ;;
    unclean) UNCL_FW=$auxval ;;
    defrag) DEFRAG_FW=$auxval ;;
    drop_portscan) PORTS=$auxval ;;
    tcp_dos_protect) TCPDOSP=$auxval ;;
    log_ping) LOGP=$auxval ;;
    log_trace) LOGT=$auxval ;;
    log_indirect_drop) LOGID=$auxval ;;
    log_indirect_broadcast) LOGBRD=$auxval ;;
        
    IFNET|IFPUB|IFWAN)
      auxval=$(echo $line | cut -d" " -f2-)
      if [ "$auxval" != "IFNET" ] || [ "$auxval" != "IFPUB" ] || [ "$auxval" != "IFWAN" ]; then
         itype="net"
         iflocrt $auxval
      fi
    ;; 
    IFLOCAL|IFLAN)
      auxval=$(echo $line | cut -d" " -f2-)
      if [ "$auxval" != "IFLOCAL" ] || [ "$auxval" != "IFLAN" ]; then
         itype="local"
         iflocrt $auxval
      fi
    ;; 
    DNS)
      auxval=$(echo $line | cut -d" " -f2-)
      [ "$auxval" != "DNS" ] && \
      lstDns $auxval
    ;;
    conntrack) 
      auxval=$(echo $line | cut -d" " -f2-)
      lstCtNat $auxval
    ;;
    conntrack_bytes)
      CT_ACCT=$auxval
    ;;
    enable_tcpreset)
      [ "$auxval" == "yes" ] && touch /usr/share/fwguardian/enable_tcprst.ctl
    ;;
    local_ports) LOCAL_P=$auxval ;;
    esac 
done 
unset IFS


######################################################
# EXTRA FIREWALL FUNCTIONS
# Virus verify, NAT and others
######################################################

pscan() { 
  $iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL ALL -j DROP
  $iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL NONE -j DROP
  $iptables -t mangle -A PREROUTING -p tcp --tcp-flags ALL FIN,URG,PSH -j DROP
  $iptables -t mangle -A PREROUTING -p tcp --tcp-flags SYN,RST SYN,RST -j DROP
  $iptables -t mangle -A PREROUTING -p tcp --tcp-flags SYN,FIN SYN,FIN -j DROP
  $iptables -t mangle -A PREROUTING -m conntrack --ctstate INVALID,NEW -m psd --psd-weight-threshold 10 --psd-delay-threshold 10000 --psd-lo-ports-weight 2 --psd-hi-ports-weight 1 -j LOG --log-level info --log-prefix "SCAN " 1>&2 2>/dev/null
}

dosprotect() {
  if [ "$1" == "do" ]; then
    ## Do a tcp kernel fine tunning
    echo 30 > /proc/sys/net/ipv4/tcp_fin_timeout
    echo 2400 > /proc/sys/net/ipv4/tcp_keepalive_time
    echo 0 > /proc/sys/net/ipv4/tcp_window_scaling
    echo 0 > /proc/sys/net/ipv4/tcp_sack
    echo 2 > /proc/sys/net/ipv4/tcp_synack_retries

    ## Try to load SYNPROXY DDoS Protection
    modprobe ipt_SYNPROXY 2>/dev/null
    modprobe nf_synproxy_core 2>/dev/null
    if [ "$SYN_C_FW" == "yes" ] && [ $(lsmod | grep synproxy | wc -l) -gt 0 ]; then
       maxconn=$(sysctl net.netfilter.nf_conntrack_max | cut -d " " -f 3)
       [ "$maxconn" == "" ] || [ "$maxconn" -lt 65536 ] && maxconn=65536

       maxsyn=$((maxconn / 3))
       hashsize=$maxsyn
       [ "$maxsyn" -lt 30000 ] && maxsyn=30000
       echo $maxsyn > /proc/sys/net/ipv4/tcp_max_syn_backlog

       [ $maxsyn -gt 30000 ] && maxsyn=30000
       echo $maxsyn > /proc/sys/net/core/somaxconn
       echo $maxconn > /proc/sys/net/core/netdev_max_backlog
       echo $hashsize > /sys/module/nf_conntrack/parameters/hashsize
       echo 0 > /proc/sys/net/netfilter/nf_conntrack_tcp_loose
       echo 1 > /proc/sys/net/ipv4/tcp_timestamps

       if [ -f $FW_DIR/securityaddon/config ]; then
          chkports=$(grep "^[\s]*check-ports\b" $FW_DIR/securityaddon/config | awk '{ if ($3 == "synproxy") count++; if (count == 1 && $3 == "synproxy") print $2; }')

          echo 1 > /proc/sys/net/ipv4/tcp_sack
          $iptables -t raw -N NoTRACK_SYNP
          $iptables -N Do_SYNPROXY
          [ -f $FW_DIR/securityaddon/greylist ] && grep "^[\s]*\(src\|dst\)-ip\b" $FW_DIR/securityaddon/greylist | awk -v ipt=$iptables '{ \
             if ($3 == "synproxy" || !$3 ) { \
                if ($1 == "src-ip") { \
                   print ipt" -t raw -A NoTRACK_SYNP -s "$2" -j RETURN"; \
                   print ipt" -A Do_SYNPROXY -s "$2" -j RETURN"; \
                } \
                else { \
                   print ipt" -t raw -A NoTRACK_SYNP -d "$2" -j RETURN"; \
                   print ipt" -A Do_SYNPROXY -d "$2" -j RETURN"; \
                } \
             } \
          }' | $sh -
          $iptables -t raw -A NoTRACK_SYNP -j CT --notrack

          if [ -f /usr/share/fwguardian/modules/simpleips.ctl ]; then
             $iptables -A Do_SYNPROXY -m recent --rcheck --name dropips -j RETURN
             $iptables -A Do_SYNPROXY -p tcp --syn -m recent --name checkips --set
          fi

          TCPOPT=""
          . $FW_DIR/securityaddon/synproxy-opts
          for i in $(echo ${IFRT[*]}); do
             # Set physdev for bridge interfaces
             indev="-i $i"
             flag=1
             if [ "$nfbridge" == "1" ]; then
                [ -f /sys/class/net/$i/brforward ] || [ ! -d /sys/class/net/$i ] && flag=0
                if [ -f /sys/class/net/$i/brport/state ]; then
                   flag=1
                   indev="-m physdev --physdev-in $i"
                fi
             fi

             # Setting SYNPROXY protection
             if [ "$flag" == "1" ]; then
                $iptables -t raw -A PREROUTING $indev -m multiport -p tcp --dport $chkports --syn -j NoTRACK_SYNP
                $iptables -A Do_SYNPROXY $indev -p tcp -j SYNPROXY --timestamp $TCPOPT
                $iptables -A Do_SYNPROXY $indev -p tcp -m conntrack --ctstate INVALID -j InvalidDROP

                echo "$iptables -A RtRules $indev -m multiport -p tcp --dport $chkports -m conntrack --ctstate INVALID,UNTRACKED -j Do_SYNPROXY" >> /usr/share/fwguardian/sproxy.forward.ctl
             fi
          done
          unset indev
       fi
       unset maxconn maxsyn hashsize
    fi
  else
    ## Restore the main tcp kernel values
    echo 60 > /proc/sys/net/ipv4/tcp_fin_timeout
    echo 7200 > /proc/sys/net/ipv4/tcp_keepalive_time
    echo 1 > /proc/sys/net/ipv4/tcp_window_scaling
    echo 1 > /proc/sys/net/ipv4/tcp_sack
  fi
}

[ "$SHARENET" == "yes" ] && IP_FWD="yes"


# SETUP THE FIREWALL INTERFACES
# Use --reconfigure-interfaces to do a full interface setup
$FW_DIR/modules/interfaces.mod $FW_DIR

# FLUSH ALL CHAINS
$ip addr ls | awk '$1 ~ /^inet$/ {print $2}' | cut -d'/' -f1 | sort | uniq > /usr/share/fwguardian/fw.ipaddr
if [ -f /proc/net/ip_tables_names ]; then
  cat /proc/net/ip_tables_names | \
     awk -v ipt=$iptables '{print ipt" -t "$1" -F"; print ipt" -t "$1" -X";}' | $sh -
else
  $iptables -F
  $iptables -X
  $iptables -t nat -F
  $iptables -t nat -X
  $iptables -t mangle -F
  $iptables -t mangle -X
fi
if [ -x "$ipset" ]; then
   $ipset -F
   $ipset -X
fi
$iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -m comment --comment "restart" -j ACCEPT
$iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -m comment --comment "restart" -j ACCEPT

#### Syslog changes
if [ ! -f /var/tmp/rsyslog ] || [ ! -d  /var/log/fwguardian ]; then
  rsyslog_f[0]="$FW_DIR/modules/tools/rsyslog/10-fwguardian.conf"
  rsyslog_f[1]="$FW_DIR/modules/tools/rsyslog/11-webauth.conf"
  rsyslog_f[2]="$FW_DIR/modules/tools/rsyslog/20-qlproxy.conf"
  service=$(which service)
  for fsyslog in $(echo ${rsyslog_f[*]}); do
     [ -f $fsyslog ] && cp -f $fsyslog /etc/rsyslog.d/
  done

  [ -f /etc/init.d/rsyslog ] && $service rsyslog restart 2>&1 >/dev/null
  touch /var/tmp/rsyslog
  unset service fsyslog
fi
[ ! -f /etc/logrotate.d/fwguardian ] && cp -f $FW_DIR/modules/tools/fwguardian.rotate /etc/logrotate.d/fwguardian


#### Admin rules
# - Allow default ssh admin services
if [ -f /etc/ssh/sshd_config ]; then
   sshport=$(grep -v "^#" /etc/ssh/sshd_config | grep -i "Port[ ]\+[0-9]\+[ ]*\$" | sed 's/.*[Pp]ort[ ]\+//')
   [ "$(echo $sshport | wc -w)" -eq 0 ] && \
      sshport=$(grep -i "#[ ]*Port[ ]\+[0-9]\+[ ]*\$" /etc/ssh/sshd_config | sed 's/.*[Pp]ort .*/22/')
else
   sshport=$(netstat -ntlp | grep " [[:digit:]]\+/ssh[d]" | awk '{print $4}' | sed 's/.*://')
fi
admport=$(cat $FW_DIR/webauth/webauth.conf | grep "^[\s]*bind" | sed 's/.*://' | tr '\n' ',')
admport="$admport$sshport"

# - Allow FwGuardian Turnkey Linux admin services
if [ -d /etc/nginx ] && [ -d /etc/webmin ]; then
   [ -f /etc/default/shellinabox ] && admport="$admport,$(grep _PORT /etc/default/shellinabox | cut -d'=' -f2)"
   [ -f /etc/webmin/miniserv.conf ] && admport="$admport,$(grep listen /etc/webmin/miniserv.conf | cut -d'=' -f2)"
   [ -f /etc/nginx/sites-enabled/kibana3 ] && admport="$admport,$(grep listen /etc/nginx/sites-enabled/kibana3 | sed 's/.*:\(.*\);/\1/')"
   echo $admport | grep "\b443\b" - >/dev/null || admport="$admport,443"
fi
$iptables -N FwAdmin 2>/dev/null
$iptables -N AllowAdmin 2>/dev/null
$iptables -A INPUT -m multiport -p tcp --dport $admport -j FwAdmin 2>/dev/null
updTrust
unset admport


############################################################
#  ACCESS POLICY
############################################################

$iptables -P INPUT DROP
$iptables -P FORWARD DROP
$iptables -P OUTPUT ACCEPT

#### Allow loopback connection
$iptables -A INPUT -i lo -j ACCEPT
$iptables -A OUTPUT -o lo -j ACCEPT

#### Cluster confs
# Restart the main cluster daemons
[ ! -f /usr/share/fwguardian/webauth/control/ignore.cluster ] && killclctl

if [ -f /usr/share/fwguardian/modules/clusterfw.ctl ]; then
   echo "### Starting cluster rules (`date`)" >>$FW_DIR/logs/cluster.base.err

   [ -f /var/tmp/gluster.group ] && rm -f /var/tmp/gluster.group 2>/dev/null
   rm -f /var/tmp/cluster.sync.peers 2>/dev/null
   perl $FW_DIR/modules/tools/cluster/clusterctl.pl --check 2>&1 >>$FW_DIR/logs/cluster.base.err

   [ ! -f /var/tmp/cluster.sync.peers ] && sleep 1
   [ ! -f /usr/share/fwguardian/cluster/ssh ] && echo $sshport > /usr/share/fwguardian/cluster/ssh

   if [ -f /var/tmp/cluster.sync.peers ]; then
      # Apply cluster confs
      $FW_DIR/modules/clusterfw.mod $FW_DIR

      # Update fw.ipaddr with all firewall vips
      if [ -f /usr/share/fwguardian/cluster.vips ]; then
         while read line; do
            grep -q "\b$line\b" /usr/share/fwguardian/fw.ipaddr || echo $line | cut -d'/' -f1 >> /usr/share/fwguardian/fw.ipaddr
         done < /usr/share/fwguardian/cluster.vips
      fi

      [ -f /usr/share/fwguardian/webauth/control/ignore.cluster ] && \
         rm -f /usr/share/fwguardian/webauth/control/ignore.cluster || \
         perl $FW_DIR/modules/tools/cluster/clusterctl.pl --daemon 2>&1 >>$FW_DIR/logs/cluster.base.err
   else
      echo -e "\tWARN: No cluster peers found!"
   fi

   # (re)Starting gluster services
   $FW_DIR/modules/tools/cluster/glusterfs/restart.sh $FW_DIR

   # Concat firewall alias
   [ -f "$FW_DIR/alias" ] && cat $FW_DIR/alias > $FW_DIR/cluster/alias || echo > $FW_DIR/cluster/alias
   [ -f "$FW_DIR/cluster/glusterfs/local/fs/alias" ] && cat $FW_DIR/cluster/glusterfs/local/fs/alias >> $FW_DIR/cluster/alias
fi
unset sshport


## DROP and log invalid connections
$iptables -N InvalidDROP
$iptables -A InvalidDROP -m limit --limit 1/s --limit-burst 1 -j LOG --log-level info --log-prefix "DROP profile Invalid "
$iptables -A InvalidDROP -j DROP

## Flush routing tables/rules
$FW_DIR/modules/flushroute.mod flush $FW_DIR

## Blacklists
if [ -f /usr/share/fwguardian/modules/bannedfw.ctl ]; then
  $iptables -t mangle -N AcBanned 
  $FW_DIR/modules/bannedfw.mod $FW_DIR access 1>/dev/null
fi

## Discover the IPS Queues
IPSQ="0"
if [ -f /etc/suricata/suricata.yaml ] || [ -f /etc/suricata/suricata-debian.yaml ]; then
   . $FW_DIR/securityaddon/suricata-ips
   [ "$IPSQ" == "0" ] && IPSQ=$(/bin/ps -ef www | grep suricata | grep -n "\-q" | grep -o ' -q ' | wc -l)

   if [ "$IPSQ" -gt 0 ]; then
      ((IPSQ--))
      [ "$IPSQ" -ge 1 ] && IPSQ=" --queue-balance 0:$IPSQ " || IPSQ=" --queue-num 0 "

      $iptables -N fw_intIPS
      $iptables -A fw_intIPS -j NFQUEUE $IPSQ --queue-bypass
   else
      IPSQ="0"
   fi
fi


#### Enable profile definitions
if [ "$PROFILE" == "yes" ]; then
  touch /usr/share/fwguardian/profiles.ctl
  $FW_DIR/modules/profile.mod $FW_DIR/profile profile
else
  rm -f /usr/share/fwguardian/profiles.ctl 2>/dev/null
fi

#### Create "secure route" chain
if [ "$IP_FWD" == "yes" ]; then
  [ "$IPDYN" == "yes" ] && $FW_DIR/modules/rtsec.mod create ipdyn || \
    $FW_DIR/modules/rtsec.mod create fixed
fi

############################################################
#  SECURITY FLAGS
############################################################

# Apply "TCP SYN Cookie" protection
[ "$SYN_C_FW" == "yes" ] && FLAG=1 || FLAG=0
echo $FLAG > /proc/sys/net/ipv4/tcp_syncookies

# Ignore echo icmp broadcasts
[ "$BRD_I_FW" == "yes" ] && FLAG=1 || FLAG=0
echo $FLAG > /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts

# Habilitando protecao para mensagens de erro
[ "$I_BE_FW" == "yes" ] && FLAG=1 || FLAG=0
echo $FLAG > /proc/sys/net/ipv4/icmp_ignore_bogus_error_responses

# Dynamic IP address (dhcp clients)
[ "$IPDYN" == "yes" ] && FLAG=1 || FLAG=0
echo $FLAG > /proc/sys/net/ipv4/ip_dynaddr

# Turn on Source Address Verification (anti-spoof)
[ "$RP_F_FW" == "yes" ] && FLAG=1 || FLAG=0
for f in /proc/sys/net/ipv4/conf/*/rp_filter; do
    echo $FLAG > $f
done

# Enable send redirects
[ "$SED_REDIR" == "yes" ] && FLAG=1 || FLAG=0
for f in /proc/sys/net/ipv4/conf/*/send_redirects; do
    echo $FLAG > $f
done

# Enable secure redirects (ICMP redirect messages only for gateways)
[ "$SEC_REDIR" == "yes" ] && FLAG=1 || FLAG=0
for f in /proc/sys/net/ipv4/conf/*/secure_redirects; do
    echo $FLAG > $f
done

# Disable ICMP Redirect Acceptance
[ "$ICMP_A_FW" == "yes" ] && FLAG=0 || FLAG=1
for f in /proc/sys/net/ipv4/conf/*/accept_redirects; do
    echo $FLAG > $f
done

# Disable source routing changes (anti-spoof)
[ "$ACC_SR_FW" == "yes" ] && FLAG=0 || FLAG=1
for f in /proc/sys/net/ipv4/conf/*/accept_source_route; do
    echo $FLAG > $f
done

# Logs de pacotes com suspeita de Spoof, Source Routed Packets, Redirect Packets
[ "$LOG_M_FW" == "yes" ] && FLAG=1 || FLAG=0
for f in /proc/sys/net/ipv4/conf/*/log_martians; do
    echo $FLAG > $f
done

# Enable packet/bytes count in conntrack table (new kernels)
[ "$CT_ACCT" == "yes" ] && FLAG=1 || FLAG=0
echo $FLAG > /proc/sys/net/netfilter/nf_conntrack_acct 2>/dev/null
unset FLAG LOG_M_FW ACC_SR_FW ICMP_A_FW RP_F_FW I_BE_FW BRD_I_FW


# Change local port range (fullnat - less sockets, server - full sockets, firewall - nat/server)
if [ "$LOCAL_P" == "fullnat" ]; then
  PORT_INI=61000
  PORT_END=65095
else
  if [ "$LOCAL_P" == "server" ]; then
     PORT_INI=1024
     PORT_END=65000
  else
     PORT_INI=32768
     PORT_END=61000
  fi
fi
echo $PORT_INI $PORT_END > /proc/sys/net/ipv4/ip_local_port_range

#### Deny bad packages ("traffic normalize")
if [ "$UNCL_FW" == "yes" ]; then
  $iptables -A INPUT -m unclean -j DROP
  [ "$IP_FWD" == "yes" ] && $iptables -A FORWARD -m unclean -j DROP
fi

#### Active defrag module (required in "-f" iptables command)
if [ "$DEFRAG_FW" == "yes" ]; then
   modprobe nf_defrag_ipv4 2>/dev/null
   modprobe nf_defrag_ipv6 2>/dev/null
fi

#### Dendy portscanners
[ "$PORTS" == "yes" ] && pscan

#### Tunning tcp parms to DOS protect
[ "$TCPDOSP" == "yes" ] && dosprotect do || dosprotect no

unset UNCL_FW PORTS TCPDOSP SYN_C_FW


#### Allow ICMP frag-needed (MTU-mss), time-exceeded and source-quench
$iptables -N AllowIcmp
$iptables -A AllowIcmp -p icmp --icmp-type fragmentation-needed -j ACCEPT
$iptables -A AllowIcmp -p icmp --icmp-type time-exceeded -j ACCEPT
$iptables -A AllowIcmp -p icmp --icmp-type source-quench -j ACCEPT
[ "$KLICMP" == "yes" ] && $iptables -A AllowIcmp -p icmp --icmp-type echo-request -m length --length 310: -j DROP

$iptables -A INPUT -p icmp -j AllowIcmp

#### Custom rules
echo "### FWRULES (`date`)" >> $FW_DIR/logs/fwrules.err
[ -f $FW_DIR/fwrules ] && $FW_DIR/fwrules start 2>&1 >>$FW_DIR/logs/fwrules.err


#### Load simpleIPS dynamic ip blacklist and INPUT firewall rules
[ -f /usr/share/fwguardian/modules/simpleips.ctl ] && $FW_DIR/modules/simpleips.mod $FW_DIR

if [ -f /usr/share/fwguardian/modules/infilters.ctl ]; then
   $iptables -N FwIn 2>/dev/null
   $iptables -A INPUT -j FwIn 2>/dev/null
   $FW_DIR/modules/infilters.mod $FW_DIR
fi


###########################################################
# Network Masquerade
# Setting FORWARD
###########################################################

######## ROUTING ACCESS (FORWARD x MASQUERADE) #########
if [ "$IP_FWD" == "yes" ] || [ "$SHARENET" == "yes" ]; then

  flagrl=0
  $iptables -I INPUT -p udp --sport 53 -m comment --comment "restart" -j ACCEPT

  #### Allow ICMP frag-needed (MTU-mss), time-exceeded and source-quench
  $iptables -A FORWARD -p icmp -j AllowIcmp

  #### Keep-alive sessions
  rm -f /usr/share/fwguardian/keepalive.ctl 2>/dev/null
  if [ "$KP_SESS" == "yes" ]; then
     touch /usr/share/fwguardian/keepalive.ctl
     $iptables -t mangle -N CNTRACK 2>/dev/null
     $iptables -t mangle -A CNTRACK -m mark ! --mark 0x0 -j CONNMARK --save-mark 2>/dev/null
     $iptables -t mangle -A POSTROUTING -j CNTRACK

     $iptables -t mangle -A PREROUTING -m mark --mark 0x0 -j CONNMARK --restore-mark 2>/dev/null
  fi

  #### Adv default gateway
  [ -f /usr/share/fwguardian/rttables.prlock ] && rm -f /usr/share/fwguardian/rttables.prlock 2>/dev/null
  if [ -f /usr/share/fwguardian/modules/rttables.ctl ]; then
     if [ -f /var/run/dgdguardian ]; then
        kill -9 $(cat /var/run/dgdguardian) 2>/dev/null
        rm -f /var/run/dgdguardian 2>/dev/null
     fi

     echo "Firewall... Allow adv. default gw!"
     $FW_DIR/modules/rttables.mod $FW_DIR/routing
     touch /var/tmp/rttables.nfchain
  fi
  [ -f /usr/share/fwguardian/keepalive.ctl ] && $iptables -t mangle -A OUTPUT -m mark --mark 0x0 -j CONNMARK --restore-mark 2>/dev/null

  #### VPN
  if [ -f /usr/share/fwguardian/modules/vpnfw.ctl ]; then
     rm -f /tmp/vpndgd 2>/dev/null
     $iptables -N FwVpn 2>/dev/null
     $iptables -A INPUT -j FwVpn 2>/dev/null

     $FW_DIR/modules/vpnfw.mod $FW_DIR/vpn init all
  fi

  ### DNAT - Dnat rules (redirections)
  if [ -f /usr/share/fwguardian/modules/rtnat.ctl ]; then
     $iptables -t nat -N PrNAT 2>/dev/null
     $iptables -t nat -A PREROUTING -j PrNAT 2>/dev/null
     $iptables -N FwNAT 2>/dev/null
     $iptables -A FORWARD -j FwNAT 2>/dev/null

     if [ -f /usr/share/fwguardian/modules/rttables.ctl ] && [ "$KP_SESS" == "yes" ]; then
        $iptables -t mangle -N CNTNat 2>/dev/null
        $iptables -t mangle -A FORWARD -j CNTNat 2>/dev/null
        touch /usr/share/fwguardian/rtablenat.ctl
     fi
   
     $FW_DIR/modules/rtnat.mod $FW_DIR/routing
     touch /var/tmp/rtnat.nfchain
  fi

  $iptables -D INPUT -p udp --sport 53 -m comment --comment "restart" -j ACCEPT

  for i in $(echo ${IFRT[*]});
  do
     # Set physdev for bridge interfaces
     indev="-i $i"
     [ "$nfbridge" == "1" ] && [ -f /sys/class/net/$i/brport/state ] && indev="-m physdev --physdev-in $i"

     ## Make secure route to IFRT
     $iptables -t mangle -I POSTROUTING -o $i -j AcBanned 2>/dev/null
     if [ "$IPDYN" == "yes" ]; then
        $FW_DIR/modules/rtsec.mod $i ipdyn

        ## Allow dhcp bootpc updates
        defgw=$($ip route get 200 2>/dev/null | cut -d" " -f3)
        if [ "$defgw" == "" ] || [ -f /usr/share/fwguardian/modules/rttables.ctl ]; then
           $iptables -A INPUT -i $i -p tcp --dport bootpc -j ACCEPT
           $iptables -A INPUT -i $i -p udp --dport bootpc -j ACCEPT
        else
           $iptables -A INPUT -i $i -s $defgw -p tcp --dport bootpc -j ACCEPT
           $iptables -A INPUT -i $i -s $defgw -p udp --dport bootpc -j ACCEPT
        fi
     else
        $FW_DIR/modules/rtsec.mod $i fixed
     fi

     ## Reject "auth" requests (113) in ftp conections
     [ "$SHARENET" == "yes" ] && $iptables -A INPUT $indev -p tcp --dport 113 -j REJECT

     ## Local network protection
     if [ "$i" ]; then
       flag=0	
       for j in $(echo ${IFLC[*]}); do
          if [ "$i" == "$j" ]; then
            flag=1
	    flagrl=1
            break
          fi
       done
     fi
     [ ! -d /sys/class/net/$i ] && flag=1
     [ "$flag" -eq 0 ] && [ ! -f /sys/class/net/$i/brport/state ] && $iptables -A FORWARD $indev -m conntrack --ctstate NEW,INVALID -j InvalidDROP
  done
  unset indev

  ## Default RtSec action
  [ "$flagrl" -eq 1 ] && $iptables -t mangle -A RtSec -m conntrack --ctstate ESTABLISHED,RELATED -j RETURN
  $iptables -t mangle -A RtSec -j LOG --log-level info --log-prefix "RtSec DROP: "
  $iptables -t mangle -A RtSec -j DROP

  if [ "$SHARENET" == "yes" ]; then
     touch /usr/share/fwguardian/fwmasq.ctl
     for i in $(echo ${DNS[*]});
     do
        $iptables -A FORWARD -d $i -p udp --dport 53 -j ACCEPT
     done
     $FW_DIR/modules/fwmasq.mod $FW_DIR $PRIV_DEF
  else
     rm -f /usr/share/fwguardian/fwmasq.ctl 2>/dev/null
     rm -f /usr/share/fwguardian/fwmasq.rules 2>/dev/null
  fi

  #### Config a proper MTU with TCPMSS
  $iptables -t mangle -A POSTROUTING -p tcp --tcp-flags SYN,RST SYN -m tcpmss --mss 1200: -j TCPMSS --clamp-mss-to-pmtu

  flag=1
else
  flag=0
fi
echo $flag > /proc/sys/net/ipv4/ip_forward
unset flag flagrl

#### Traffic Shape
if [ -f /usr/share/fwguardian/modules/tfstart.ctl ]; then
   $FW_DIR/modules/tfstart.mod $FW_DIR/tfshape
   touch /var/tmp/tfstart.nfchain
fi


############################################################
#  Conntrack MODULES
############################################################

echo "### Modprobe (`date`)" >> $FW_DIR/logs/modprobe.err
for i in $(echo ${CTNAT[*]});
do
   if [ "$i" == "ALL" ] && [ $(echo ${CTNAT[*]} | wc -w) -eq 1 ]; then
      for j in $(find /lib/modules/$(uname -r) -name ??_nat_* -print | grep -i netfilter | \
	  sed 's/.*\///' | sed 's/\..*\.gz$//; s/\.ko$//' | cut -d'.' -f1); do modprobe $j 2>>$FW_DIR/logs/modprobe.err ; done
      break
   else
      echo "modprobe ip_nat_$i" | $sh - 2>&1 >>$FW_DIR/logs/modprobe.err
      echo "modprobe nf_nat_$i" | $sh - 2>&1 >>$FW_DIR/logs/modprobe.err
   fi 
done


############################################################
# ACCESS DEFINITIONS
############################################################

#### Security addons: global IPS and anti-P2P filters
# - you can disable this global feature and make manual configuration into fwroute.rules
if [ -f /usr/share/fwguardian/modules/global_ipp2p.ctl ] || [ -f /usr/share/fwguardian/modules/global_ips.ctl ]; then
  grep -v '^\s*\(#\|;\|$\)' $FW_DIR/interfaces | while read i; do
     suips=$(echo $i | awk '{ print $10; }')
     ipp2p=$(echo $i | awk '{ print $11; }')

     # Set physdev for bridge interfaces
     i=$(echo $i | cut -d" " -f1)
     if [ -d /sys/class/net/$i ]; then
        indev="-i $i"
        outdev="-o $i"
        if [ "$nfbridge" == "1" ] && [ -f /sys/class/net/$i/brport/state ]; then
           indev="-m physdev --physdev-in $i"
           outdev="-m physdev --physdev-out $i"
        fi

        # Select IPS interfaces
        flag=1
        [ "$suips" == "0" ] || [ "$IPSQ" == "0" ] && flag=0
        if [ -f /usr/share/fwguardian/modules/global_ips.ctl ] && [ $flag == 1 ]; then
           $iptables -t mangle -A PREROUTING $indev -j NFQUEUE $IPSQ --queue-bypass
           $iptables -t mangle -A POSTROUTING $outdev -j NFQUEUE $IPSQ --queue-bypass
        fi

        # Drop P2P: You can use "mangle:DropP2P" policy in profile.def to write bypass rules
        if [ -f /usr/share/fwguardian/modules/global_ipp2p.ctl ] && [ "$ipp2p" == "1" ]; then
           $iptables -t mangle -N DropP2P 2>/dev/null
           $iptables -t mangle -A DropP2P -m limit --limit 2/s --limit-burst 2 -j LOG --log-level info --log-prefix "DROP profile DropP2P "
           $iptables -t mangle -A DropP2P -j DROP
           $iptables -t mangle -A POSTROUTING $outdev -m ipp2p --edk --kazaa --gnu --bit --apple --winmx --soul --ares -j DropP2P
        fi
     fi
  done
  unset indev outdev suips ipp2p
fi


#### ADMINISTRATOR (INPUT)

if [ "$WEB_SERVER" == "yes" ]; then
  touch /usr/share/fwguardian/webserver.ctl
  [ "$WEB_HEALTH" == "yes" ] && touch /usr/share/fwguardian/webhealth.ctl
else
  killweb
fi

if [ "$SHARENET" == "yes" ] || [ "$IP_FWD" == "yes" ] ; then

  ## External Networks - routers
  [ -f /usr/share/fwguardian/rtfilters.frtlock ] && rm -f /usr/share/fwguardian/rtfilters.frtlock 2>/dev/null
  if [ -f /usr/share/fwguardian/modules/rtfilters.ctl ] ; then
    $iptables -N RtRules 2>/dev/null
    $iptables -A FORWARD -j RtRules 2>/dev/null

    $FW_DIR/modules/rtfilters.mod $FW_DIR/routing
  fi

  ## ICMP echo-request limits
  for i in $(echo ${IFLC[*]});
  do
    $iptables -A FORWARD -i $i -p icmp --icmp-type echo-request -m limit --limit 1/s --limit-burst 1 -j ACCEPT
  done

  ## Host profiles and MSN
  if [ -f /usr/share/fwguardian/modules/fwhosts.ctl ] && [ "$PROFILE" == "yes" ]; then
    $iptables -N FwHosts 2>/dev/null
    $iptables -A FORWARD -j FwHosts 2>/dev/null
    $FW_DIR/modules/fwhosts.mod $FW_DIR/
  fi
  if [ -f /usr/share/fwguardian/modules/msnctl.ctl ]; then
    echo "### MSN control (`date`)" >> $FW_DIR/logs/fwmsn.err
    $FW_DIR/modules/msnctl.mod $FW_DIR/ 2>> $FW_DIR/logs/fwmsn.err
  fi

  # Default profile (priv_default)
  [ "$SHARENET" == "yes" ] && $sh /usr/share/fwguardian/fwmasq.rules 2>> $FW_DIR/logs/fwmasq.err

  # Stateful routing
  $iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

  # Kill NBT packets
  if [ "$KNBT" == "yes" ]; then
     $iptables -A FORWARD -m multiport -p tcp --dport 135:139,445 -j REJECT --reject-with tcp-reset
     $iptables -A FORWARD -m multiport -p udp --dport 137:138,445 -j REJECT
  fi

  if [ "$LOGID" == "yes" ]; then
     [ "$LOGBRD" == "yes" ] && \
     $iptables -A FORWARD -m conntrack --ctstate NEW -j LOG --log-level info --log-prefix "Indirect DROP (out):" || \
     $iptables -A FORWARD -m conntrack --ctstate NEW -m pkttype ! --pkt-type broadcast -j LOG --log-level info --log-prefix "Indirect DROP (out):"
  fi

  # Kill Web packets
  [ "$KWEB" == "yes" ] && $iptables -A FORWARD -m multiport -p tcp --dport 80,443,8080 --syn -j REJECT --reject-with tcp-reset

  # Deny other forward packages
  $iptables -A FORWARD -j DROP

  unset PRIV_DEF mifrt mrede conta
fi
   

#### Stateful input
$iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

#### TOS optimize
if [ "$OPTOS" == "yes" ]; then
   # TOS classify
   $iptables -t mangle -N TOScls 2>/dev/null
   $iptables -t mangle -A TOScls -m multiport -p udp --dport 53,123 -j TOS --set-tos Minimize-Delay
   $iptables -t mangle -A TOScls -m multiport -p tcp --dport 21,22,23 -j TOS --set-tos Minimize-Delay
   $iptables -t mangle -A TOScls -m length --length 0:512 -j TOS --set-tos Minimize-Delay
   $iptables -t mangle -A TOScls -m length --length 1024: -j TOS --set-tos Maximize-Throughput
   $iptables -t mangle -A TOScls -m multiport -p tcp --dport 20,25,110,143,587 -j TOS --set-tos Maximize-Throughput
   $iptables -t mangle -A TOScls -p udp --dport 1024: -j TOS --set-tos Maximize-Throughput
   if [ -f /usr/share/fwguardian/rtdgd.ctl ]; then
      $iptables -t mangle -A TOScls -p icmp -j TOS --set-tos Maximize-Throughput
      cat /usr/share/fwguardian/rtdgd.ctl | awk '{ \
         print "iptables -t mangle -A TOScls -d "$2" -p icmp -j TOS --set-tos Minimize-Delay"; \
      }' | $sh -
   fi
   for i in $(echo ${IFRT[*]});
   do
      # Set physdev for bridge interfaces
      outdev="-o $i"
      [ "$nfbridge" == "1" ] && [ -f /sys/class/net/$i/brport/state ] && outdev="-m physdev --physdev-out $i"

      [ "$VITOS" == "yes" ] && $iptables -t mangle -A POSTROUTING $outdev -j TOScls || \
                               $iptables -t mangle -A POSTROUTING $outdev -m tos --tos Normal-Service -j TOScls
   done
   unset outdev

   # Fix Minimize-Delay TOS
   if [ "$FIXTOS" == "yes" ]; then
      $iptables -t mangle -N TOSFix 2>/dev/null
      $iptables -t mangle -A TOSFix -p tcp -m length --length 0:512 -j RETURN
      $iptables -t mangle -A TOSFix -m limit --limit 2/s --limit-burst 10 -j RETURN
      $iptables -t mangle -A TOSFix -j TOS --set-tos Maximize-Throughput

      $iptables -t mangle -A POSTROUTING -p tcp -m tos --tos Minimize-Delay -j TOSFix
   fi
fi

# Fix POSTROUTING chain order
[ "$IP_FWD" == "yes" ] && $FW_DIR/modules/flushnftables.mod start 2>/dev/null



###############################################################
# LOG AND DENY ALL OTHER INPUT PACKAGES (Indirect drops)
###############################################################

if [ "$LOGP" == "yes" ]; then
  $iptables -A INPUT -m limit --limit 6/min --limit-burst 3 -p icmp --icmp-type echo-request \
  	 -j LOG --log-level info --log-prefix " PING: "
fi
$iptables -A INPUT -m limit --limit 30/min --limit-burst 1 -p icmp --icmp-type echo-request \
    -j REJECT --reject-with icmp-port-unreachable

[ "$LOGP" == "yes" ] || [ "$LOGID" == "yes" ] && $iptables -A INPUT -p icmp --icmp-type echo-request -j DROP
if [ "$LOGID" == "yes" ]; then
   [ "$LOGBRD" == "yes" ] && \
     $iptables -A INPUT -m conntrack --ctstate NEW -j LOG --log-level info --log-prefix "Indirect DROP (in):" || \
     $iptables -A INPUT -m conntrack --ctstate NEW -m pkttype ! --pkt-type broadcast -j LOG --log-level info --log-prefix "Indirect DROP (in):"
fi
[ "$LOGT" == "yes" ] && sysctl -w net.netfilter.nf_log.2=ipt_LOG


[ -f $FW_DIR/fwrules.end ] && $FW_DIR/fwrules.end start 2>&1 >>$FW_DIR/logs/fwrules.err

# Make CPU Isolate (grub only)
if [ -f "$FW_DIR/addon/cpu_isolate" ]; then
   upd=0
   cpulst=$(grep -v "^[\s]*\(\#\|$\|auto\)" $FW_DIR/addon/cpu_isolate)
   [ -f /etc/default/grub ] && [ "$cpulst" != "" ] && [ "$cpulst" != "none" ] && upd=$(grep "[\s]*GRUB.*\bisolcpus=$cpulst\b" /etc/default/grub >/dev/null && echo 0 || echo 1)
   if [ "$upd" == "1" ]; then
      sed -i '/GRUB_CMDLINE_LINUX_DEFAULT/ s/\s*isolcpus=[0-9]\(,[0-9]\)*//g;' /etc/default/grub
      [ "$cpulst" != "auto" ] && sed -i "/GRUB_CMDLINE_LINUX_DEFAULT/ s/\"$/ isolcpus=$cpulst\"/" /etc/default/grub

      logger=$(which logger)
      /usr/sbin/update-grub | $logger -i -t "fwguardian(webauth)/update-grub(isolcpus):"
   fi
fi

# Remove state rules used to keep state into restart script
$iptables -D INPUT -m conntrack --ctstate ESTABLISHED,RELATED -m comment --comment "restart" -j ACCEPT
$iptables -D FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -m comment --comment "restart" -j ACCEPT

$iptables -A INPUT -j DROP

if [ "$WEB_SERVER" == "yes" ]; then
   [ ! -f /usr/share/fwguardian/webauth/control/ignore ] && killweb
   $FW_DIR/webauth/webstart $FW_DIR/webauth
fi

[ -x $FW_DIR/postload ] && $FW_DIR/postload 2>&1 >>$FW_DIR/logs/postload.err

echo "Firewall... Finished!"
